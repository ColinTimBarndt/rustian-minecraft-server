const fs = require("fs");
const lib = require("./generator_lib");

const file = new lib.RustCodeGenerator("../generated_code/registries.rs");

file.commentLine(
  "This file was automatically generated based on",
  "data generated by the original Java game"
);

file.writeLine('#![ignore = "unused"]');
file.writeLine("use crate::helpers::{NamespacedKey, Registry};");

/**
 * @type {{
 *   [registry_key: string]: {
 *     protocol_id: number;
 *     entries: {
 *       [entry_key: string]: {
 *         protocol_id: number;
 *       }
 *     };
 *   }
 * }}
 */
const registryData = JSON.parse(
  fs.readFileSync("../generated/reports/registries.json")
);

Object.entries(registryData).forEach(([registryKeyStr, registry]) => {
  const registryKey = lib.NamespacedKey.fromString(registryKeyStr);
  const registryRustName = lib.toCamelCase(registryKey.id, true);
  file.writeLine(
    "#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]",
    "#[allow(non_camel_case_types)]"
  );
  file.documentLine(`Key: \`${registryKeyStr}\``);
  {
    const en = new lib.EnumGenerator(file, registryRustName, true);
    Object.entries(registry.entries).forEach(([entryKeyStr, entry]) => {
      const entryKey = lib.NamespacedKey.fromString(entryKeyStr);
      const entryRustName = lib
        .toCamelCase(entryKey.id, true)
        .replace(/\./g, "_");
      en.addEnumValue(entryRustName, entry.protocol_id);
    });
    en.finish();
  }
  {
    const impl = new lib.ImplGenerator(file, registryRustName);
    impl.writeLine(`pub const ID: usize = ${registry.protocol_id};`);
    impl.finish();
  }
  // implement Registry
  {
    const impl = new lib.ImplGenerator(file, registryRustName, "Registry");
    // get_registry_key(&self) -> NamespacedKey
    {
      const fn = new lib.FunctionGenerator(
        impl,
        "get_registry_key",
        "NamespacedKey"
      );
      fn.addParam("&self");
      fn.indent().write(
        "NamespacedKey::new(crate::helpers::MINECRAFT_NAMESPACE, "
      );
      const inline = new lib.InlinedGenerator(fn);
      const match = new lib.MatchGenerator(inline, "self");
      Object.entries(registry.entries).forEach(([entryKeyStr]) => {
        const entryKey = lib.NamespacedKey.fromString(entryKeyStr);
        const entryRustName = lib
          .toCamelCase(entryKey.id, true)
          .replace(/\./g, "_");
        match.addMatchArm(`Self::${entryRustName}`, `"${entryKey.id}"`);
      });
      match.finish();
      inline.finish();
      fn.write(")").newLine();
      fn.finish();
    }
    // from_registry_key(key: &NamespacedKey) -> Option<Self>
    {
      const fn = new lib.FunctionGenerator(
        impl,
        "from_registry_key",
        "Option<Self>"
      );
      fn.addParam("key", "&NamespacedKey");
      fn.writeLine(
        "if *key.namespace() != crate::helpers::MINECRAFT_NAMESPACE {return None;}"
      );
      fn.indent().write("Some(");
      const inline = new lib.InlinedGenerator(fn);
      const match = new lib.MatchGenerator(inline, "&**key.key()");
      Object.entries(registry.entries).forEach(([entryKeyStr]) => {
        const entryKey = lib.NamespacedKey.fromString(entryKeyStr);
        const entryRustName = lib
          .toCamelCase(entryKey.id, true)
          .replace(/\./g, "_");
        match.addMatchArm(`"${entryKey.id}"`, `Self::${entryRustName}`);
      });
      match.addMatchArm("_", "{return None;}");
      match.finish();
      inline.finish();
      fn.write(")").newLine();
      fn.finish();
    }
    impl.finish();
  }
});

file.finish();
