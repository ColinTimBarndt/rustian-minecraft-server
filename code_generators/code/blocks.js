/**
 * Generates code based on the original game data that represents
 * every block in the block using a type enum and state structures.
 *
 * This works by creating an array with every block type base id.
 * The state structure then adds a state offset to the base id.
 * The resulting number is unique for each variation of a block.
 * This code does not include NBT data for tile entities. They
 * must be handled and saved separately.
 * @author Colin Tim Barndt
 */
const fs = require("fs");
const lib = require("./generator_lib");

const file = new lib.RustCodeGenerator("../generated_code/blocks.rs");

file.commentLine(
  "This file was automatically generated based on",
  "data generated by the original Java game"
);

file.writeLine("#![allow(unused)]");
file.writeLine("use crate::helpers::{NamespacedKey, Registry};");

/**
 * Block data exported from Java Minecraft
 * @type {{
 *   [blockId: string]: {
 *     states: BlockStateData[];
 *     properties: {
 *       [propertyName: string]: string[];
 *     };
 *   };
 * }}
 * @typedef {{
 *   properties: {
 *     [propertyName: string]: string;
 *   };
 *   id: number;
 *   default?: boolean;
 * }} BlockStateData
 */
const data = JSON.parse(fs.readFileSync("../generated/reports/blocks.json"));

{
  // Calculate the block id array and define constants
  file.documentLine(
    "Internal base block ids of all blocks (not including states)"
  );
  file
    .writeLine(`const BLOCK_ID_BASES: [usize; ${Object.keys(data).length}] = [`)
    .indent(2);
  let colWidth = 0;
  let largestId = 0;
  for (blockId in data) {
    // Get the block state with the lowest id
    let [firstState] = data[blockId].states.sort((a, b) => a.id - b.id);
    // Maintain some code beauty
    if (colWidth > 80) {
      file.newLine().indent(2);
      colWidth = 0;
    }
    let s = `${firstState.id},`;
    largestId = Math.max(largestId, firstState.id);
    file.write(s);
    colWidth += s.length;
  }
  file.newLine().writeLine("];").newLine();
  file.documentLine("Bits needed to represent all block states");
  file.writeLine(
    `pub const USED_PALETTE_BITS: u8 = ${Math.ceil(Math.log2(largestId))};`
  );
  file.newLine();
}

/**
 * @type {string[]}
 */
const WOOD_TYPES = Object.entries(data)
  // Map from [blockName, blockData] to [NamespacedKey, blockData]
  .map(([name, block]) => [lib.NamespacedKey.fromString(name), block])
  // Filter by id
  .filter(([{ id }, block]) => id.endsWith("_planks"))
  .map(([{ id }, block]) => id.substring(0, id.length - "_planks".length));
/**
 * @type {string[]}
 */
const COLORS = Object.entries(data)
  // Map from [blockName, blockData] to [NamespacedKey, blockData]
  .map(([name, block]) => [lib.NamespacedKey.fromString(name), block])
  // Filter by id
  .filter(([{ id }, block]) => id.endsWith("_stained_glass_pane"))
  // Map extracted colors
  .map(([{ id }, block]) =>
    id.substring(0, id.length - "_stained_glass_pane".length)
  );

/**
 * Some blocks have the exact same block state data. To save resources and for simplicity,
 * they are grouped so they will get the same state data struct.
 * @type {Map<string, string>}
 */
const similarStructures = new Map([
  ...["glass_pane", ...prefixColors("stained_glass_pane")].map((name) => [
    name,
    "glass_pane",
  ]),
  ...["melon_stem", "pumpkin_stem"].map((name) => [name, "crop_stem"]),
  ...prefixColors("bed").map((name) => [name, "bed"]),
  ...prefixColors("banner").map((name) => [name, "banner"]),
  //...prefixColors("wall_banner").map(name=>[name,"wall_banner"]), // Overwritten by Cardinal
  //...prefixColors("glazed_terracotta").map(name=>[name,"glazed_terracotta"]), // Overwritten by Cardinal
  ...similarityFilter("stairs", "_stairs"),
  ...similarityFilter("sign", "_sign"),
  ...similarityFilter("button", "_button"),
  ...similarityFilter("wall_sign", "_wall_sign"),
  ...similarityFilter("piston", "piston"), // piston and sticky_piston
  ...similarityFilter("piston_head", "piston_head"), // (see above) for heads
  ...similarityFilter("wall", "_wall"),
  ...similarityFilter("slab", "_slab"),
  ...similarityFilter("fence", "_fence"),
  ...similarityFilter("fence_gate", "_fence_gate"),
  ...similarityFilter("coral_wall_fan", "_coral_wall_fan"),
  ...similarityFilter("command_block", "command_block"), // normal, repeating and chain
  ...prefixWood("sapling").map((name) => [name, "tree_sapling"]),
  ...prefixWood("door").map((name) => [name, "door"]),
  ...prefixWood("trapdoor").map((name) => [name, "trapdoor"]),
  ...Object.entries(data) // Waterlogged
    .filter(([type, val]) => {
      if (!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      return props.length == 1 && props[0] == "waterlogged";
    })
    .map(([type, val]) => lib.NamespacedKey.fromString(type).id)
    .map((name) => [name, "waterlogged"]),
  ...Object.entries(data) // Cardinal
    .filter(([type, val]) => {
      if (!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if (!(props.length == 1 && props[0] == "facing")) return false;
      let { facing } = val.properties;
      return (
        facing.length == 4 &&
        facing.includes("north") &&
        facing.includes("south") &&
        facing.includes("west") &&
        facing.includes("east")
      );
    })
    .map(([type, val]) => lib.NamespacedKey.fromString(type).id)
    .map((name) => [name, "cardinal"]),
  ...Object.entries(data) // Axis
    .filter(([type, val]) => {
      if (!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if (!(props.length == 1 && props[0] == "axis")) return false;
      let { axis } = val.properties;
      return (
        axis.length == 3 &&
        axis.includes("x") &&
        axis.includes("y") &&
        axis.includes("z")
      );
    })
    .map(([type, val]) => lib.NamespacedKey.fromString(type).id)
    .map((name) => [name, "axis"]),
  ...Object.entries(data) // Block Face
    .filter(([type, val]) => {
      if (!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if (!(props.length == 1 && props[0] == "facing")) return false;
      let { facing } = val.properties;
      return (
        facing.length == 6 &&
        facing.includes("north") &&
        facing.includes("east") &&
        facing.includes("south") &&
        facing.includes("west") &&
        facing.includes("up") &&
        facing.includes("down")
      );
    })
    .map(([type, val]) => lib.NamespacedKey.fromString(type).id)
    .map((name) => [name, "block_face"]),
  ...Object.entries(data) // Cardinal Lightable
    .filter(([type, val]) => {
      if (!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if (
        !(
          props.length == 2 &&
          props.includes("facing") &&
          props.includes("lit")
        )
      )
        return false;
      let { facing, lit } = val.properties;
      return (
        facing.length == 4 &&
        lit.length == 2 &&
        facing.includes("north") &&
        facing.includes("east") &&
        facing.includes("south") &&
        facing.includes("west") &&
        lit.includes("true") &&
        lit.includes("false")
      );
    })
    .map(([type, val]) => lib.NamespacedKey.fromString(type).id)
    .map((name) => [name, "cardinal_lightable"]),
  ...[...prefixWood("pressure_plate"), "stone_pressure_plate"].map((name) => [
    name,
    "pressure_plate",
  ]),
  /*...[
    ...prefixWood("log"),
    ...prefixWood("wood")
  ].flatMap(name=>[[name,"axis"], ["stripped_"+name,"axis"]]),*/
  ...prefixWood("leaves").map((name) => [name, "leaves"]),
  ...["water", "lava"].map((name) => [name, "fluid"]),
  ...["brown", "red"].map((name) => [
    name + "_mushroom_block",
    "mushroom_block",
  ]),
]);
console.log("Similar structs:");
console.log(similarStructures);

/**
 * Blocks that have additional data are stored here
 * as namespaced block ids
 * @type {Set<string>}
 */
const blocksWithData = new Set();

// Block enum
{
  file.writeLine("#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]");
  let enumGen = new lib.EnumGenerator(file, "Block", true);
  for (let blockId in data) {
    const key = lib.NamespacedKey.fromString(blockId);
    const camelCaseName = lib.toCamelCase(key.id);
    let entry = data[blockId];
    let props = null;
    if ("properties" in entry) {
      let camelCasePropName = camelCaseName;
      if (similarStructures.has(key.id)) {
        camelCasePropName = lib.toCamelCase(similarStructures.get(key.id));
      }
      props = `${camelCasePropName}Data`;
      blocksWithData.add(key.toString());
    }
    enumGen.addEnumValue(camelCaseName, props ? [props] : undefined);
  }
  enumGen.finish();
}
file.newLine();
// Block enum functions
{
  let impl = new lib.ImplGenerator(file, "Block");
  // fn from_state(state: usize) -> Option<Self>
  {
    impl.documentLine(
      "Attempts to create a Block structure from the given block state id"
    );
    let fn = new lib.FunctionGenerator(
      impl,
      "from_state",
      "Option<Self>",
      true
    );
    fn.addParam("state", "usize");
    fn.commentLine(
      "Get the base id of the block (block id without the offset)"
    );
    fn.writeLine(
      "let base = BLOCK_ID_BASES[BLOCK_ID_BASES.binary_search(&state).unwrap_or_else(|x| x-1)];"
    );
    let match = new lib.MatchGenerator(fn, "base");
    for (let blockKey in data) {
      // Get the state with the lowest (offset) id
      let [firstState] = data[blockKey].states.sort((a, b) => a.id - b.id);
      const key = lib.NamespacedKey.fromString(blockKey);
      const camelCaseName = lib.toCamelCase(key.id);
      if (blocksWithData.has(blockKey)) {
        let stateName = similarStructures.has(key.id)
          ? lib.toCamelCase(similarStructures.get(key.id))
          : camelCaseName;
        stateName += "Data";
        match.addMatchArm(
          "" + firstState.id,
          `${stateName}::from_offset(state - base).map(|state| Self::${camelCaseName}(state))`
        );
      } else {
        match.addMatchArm("" + firstState.id, `Some(Self::${camelCaseName})`);
      }
    }
    match.addMatchArm("_", "None");
    match.finish();
    fn.finish();
  }
  // fn to_state(self) -> usize
  {
    impl.documentLine("Converts this Block back to its state id");
    let fn = new lib.FunctionGenerator(impl, "to_state", "usize", true);
    fn.addParam("self");
    let match = new lib.MatchGenerator(fn, "self");
    for (let blockKey in data) {
      const key = lib.NamespacedKey.fromString(blockKey);
      const camelCaseName = lib.toCamelCase(key.id);

      let [firstState] = data[blockKey].states.sort((a, b) => a.id - b.id);
      if (blocksWithData.has(blockKey)) {
        match.addMatchArm(
          `Self::${camelCaseName}(s)`,
          `${firstState.id} + s.to_offset()`
        );
      } else {
        match.addMatchArm(`Self::${camelCaseName}`, "" + firstState.id);
      }
    }
    match.finish();
    fn.finish();
  }
  impl.finish();
}

// Block enum Registry functions
{
  let impl = new lib.ImplGenerator(file, "Block", "Registry");
  // fn get_id(&self) -> usize
  {
    let fn = new lib.FunctionGenerator(impl, "get_id", "usize");
    fn.addParam("&self");
    fn.writeLine("(*self).to_state()");
    fn.finish();
  }
  // fn from_id(id: usize) -> Option<Self>
  {
    let fn = new lib.FunctionGenerator(impl, "from_id", "Option<Self>");
    fn.addParam("id", "usize");
    fn.writeLine("Self::from_state(id)");
    fn.finish();
  }
  // fn get_registry_key(&self) -> NamespacedKey
  {
    let fn = new lib.FunctionGenerator(
      impl,
      "get_registry_key",
      "NamespacedKey"
    );
    fn.addParam("&self");
    fn.indent().write("let name: &str = ");
    let inlineMatch = new lib.InlinedGenerator(fn);
    let match = new lib.MatchGenerator(inlineMatch, "self");
    for (let blockKey in data) {
      const key = lib.NamespacedKey.fromString(blockKey);
      const camelCaseName = lib.toCamelCase(key.id);
      if (blocksWithData.has(blockKey)) {
        match.addMatchArm(`Self::${camelCaseName}(_)`, `&"${key.id}"`);
      } else {
        match.addMatchArm(`Self::${camelCaseName}`, `&"${key.id}"`);
      }
    }
    match.finish();
    inlineMatch.finish();
    fn.write(";").newLine();
    fn.writeLine(
      "NamespacedKey::new(crate::helpers::MINECRAFT_NAMESPACE, name)"
    );
    fn.finish();
  }
  // fn from_registry_key(key: &NamespacedKey) -> Option<Self>
  {
    let fn = new lib.FunctionGenerator(
      impl,
      "from_registry_key",
      "Option<Self>"
    );

    const hashAlgorhitm = require("./hash_algorhitm");
    let hashingAlgo = hashAlgorhitm.findAlgorhitmFor(
      Object.keys(data).map((key) => lib.NamespacedKey.fromString(key).id)
    );
    if (hashingAlgo === null) {
      throw new Error("Unable to find a hashing algorhitm");
    }

    console.log("Found hashing algorhitm: " + hashingAlgo);

    fn.addParam("key", "&NamespacedKey");
    fn.writeLine(
      "if *key.namespace() != crate::helpers::MINECRAFT_NAMESPACE {"
    );
    fn.indent(2).write("return None;").newLine();
    fn.writeLine("}");
    fn.writeLine(
      `let hash = ${lib.toSnakeCase(hashingAlgo)}(&(key.key()).clone().into());`
    );
    fn.indent().write("return Some(");
    {
      let inline = new lib.InlinedGenerator(fn);
      let hashMatch = new lib.MatchGenerator(inline, "hash");
      let algoJSImpl = hashAlgorhitm.getJSImplementation(hashingAlgo);
      Object.keys(data)
        // Map blockKey => [blockKey, NamespacedKey, hash]
        .map((blockKey) => {
          let key = lib.NamespacedKey.fromString(blockKey);
          return [blockKey, key, algoJSImpl(key.id)];
        })
        // Sort by hash
        .sort(([_a1, _a2, hashA], [_b1, _b2, hashB]) => hashA - hashB)
        .forEach(([blockKey, key, hash]) => {
          let camelCaseName = lib.toCamelCase(key.id);
          if (blocksWithData.has(blockKey)) {
            let stateName = similarStructures.has(key.id)
              ? lib.toCamelCase(similarStructures.get(key.id))
              : camelCaseName;
            stateName += "Data";
            hashMatch.addMatchArm(
              "" + hash,
              `if *key.key() == "${key.id}" {Self::${camelCaseName}(${stateName}::default())} else {return None;}`
            );
          } else {
            hashMatch.addMatchArm(
              "" + hash,
              `if *key.key() == "${key.id}" {Self::${camelCaseName}} else {return None;}`
            );
          }
        });
      hashMatch.addMatchArm("_", (gen) => {
        let block = new lib.CodeBlockGenerator(gen);
        block.writeLine("return None;");
        block.finish();
      });
      hashMatch.finish();
      inline.finish();
    }
    fn.write(");").newLine();
    fn.newLine();
    fn.writeLine("#[inline]");
    hashAlgorhitm.writeRustFunction(fn, hashingAlgo);
    fn.finish();
  }
  impl.finish();
}

/**
 * @typedef {{
 *   map: {[valueName: string]: string};
 *   type: string;
 *   native: boolean;
 *   bounds?: [number, number];
 *   exhaustive?: boolean;
 *   generate: () => void;
 *   createRustValue: (valueName: string) => string;
 *   getRustValue: (varName: string) => string;
 *   getRustCompareToValue: (value: string) => string;
 * }} PropertyType
 * A list of types that are commonly used in the game
 * and can therefore be grouped for simplicity
 * @type {PropertyType[]}
 */
const commonPropertyTypes = [
  {
    map: {
      true: "true",
      false: "false",
    },
    type: "bool",
    native: true,
    exhaustive: true,
    generate: null,
    createRustValue: (v) => v,
    getRustValue: getPropertyValue,
    getRustCompareToValue: (v) => v,
  },
  {
    map: {
      head: "Head",
      foot: "Foot",
    },
    type: "BedPartProperty",
    native: false,
    exhaustive: true,
    generate: makePropertyStruct,
    createRustValue: createEnumPropertyValue,
    getRustValue: getPropertyValue,
    getRustCompareToValue: getEnumPropertyCompareToValue,
  },
  {
    map: {
      x: "X",
      y: "Y",
      z: "Z",
    },
    type: "AxisProperty",
    native: false,
    exhaustive: true,
    generate: makePropertyStruct,
    createRustValue: createEnumPropertyValue,
    getRustValue: getPropertyValue,
    getRustCompareToValue: getEnumPropertyCompareToValue,
  },
  {
    map: {
      floor: "Floor",
      wall: "Wall",
      ceiling: "Ceiling",
    },
    type: "FaceProperty",
    native: false,
    exhaustive: true,
    generate: makePropertyStruct,
    createRustValue: createEnumPropertyValue,
    getRustValue: getPropertyValue,
    getRustCompareToValue: getEnumPropertyCompareToValue,
  },
  {
    map: {
      single: "Single",
      left: "Left",
      right: "Right",
    },
    type: "ChestTypeProperty",
    native: false,
    exhaustive: true,
    generate: makePropertyStruct,
    createRustValue: createEnumPropertyValue,
    getRustValue: getPropertyValue,
    getRustCompareToValue: getEnumPropertyCompareToValue,
  },
  {
    map: {
      up: "Up",
      side: "Side",
      none: "None",
    },
    type: "RedstoneWireConnectionProperty",
    native: false,
    exhaustive: true,
    generate: makePropertyStruct,
    createRustValue: createEnumPropertyValue,
    getRustValue: getPropertyValue,
    getRustCompareToValue: getEnumPropertyCompareToValue,
  },
  {
    map: {
      north: "North",
      south: "South",
      west: "West",
      east: "East",
    },
    type: "CardinalFacingProperty",
    native: false,
    exhaustive: true,
    generate: makePropertyStruct,
    createRustValue: createEnumPropertyValue,
    getRustValue: getPropertyValue,
    getRustCompareToValue: getEnumPropertyCompareToValue,
  },
  {
    map: {
      north: "North",
      south: "South",
      west: "West",
      east: "East",
      up: "Up",
      down: "Down",
    },
    type: "BlockFacingProperty",
    native: false,
    exhaustive: true,
    generate: makePropertyStruct,
    createRustValue: createEnumPropertyValue,
    getRustValue: getPropertyValue,
    getRustCompareToValue: getEnumPropertyCompareToValue,
  },
];
/**
 * Stores functions that generate all the required
 * property structures
 * @type {Map<string, () => void>}
 */
const propertyStructGeneratorFunctions = new Map();

/**
 * Prevent duplicate structures
 * @type {Set<string>}
 */
const similarExistingStructures = new Set();

file.newLine();
file.commentLine("Block state data structures");
file.newLine();
for (let blockKey of blocksWithData) {
  let key = lib.NamespacedKey.fromString(blockKey);
  let dataEntry = data[blockKey];
  if (similarStructures.has(key.id)) {
    key.id = similarStructures.get(key.id);

    // Do not generate double entries
    if (similarExistingStructures.has(key.id)) continue;
    similarExistingStructures.add(key.id);
  }
  const camelCaseName = lib.toCamelCase(key.id);

  file.writeLine("#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]");
  /**
   * @type {{[name: string]: string}}
   */
  const structAttributes = {};
  /**
   * @type {Map<string, PropertyType>}
   */
  const structAttributeTypes = new Map();

  for (let propName in dataEntry.properties) {
    let propValues = dataEntry.properties[propName];
    let type = findCommonPropertyType(propValues);
    // If the state property is uncommon, create a new enum
    if (type === null) {
      type = {
        map: {},
        type: `${camelCaseName}${lib.toCamelCase(propName)}Property`,
        native: false,
        exhaustive: true,
        generate: makePropertyStruct,
        createRustValue: createEnumPropertyValue,
        getRustValue: getPropertyValue,
        getRustCompareToValue: getEnumPropertyCompareToValue,
      };

      propValues.forEach((val) => (type.map[val] = lib.toCamelCase(val)));
    }

    if (!type.native && !propertyStructGeneratorFunctions.has(type.type)) {
      propertyStructGeneratorFunctions.set(type.type, () => type.generate());
    }

    structAttributes[propName] = type.type;
    structAttributeTypes.set(propName, type);
  }

  lib.writeStruct(
    file,
    `${camelCaseName}Data`,
    structAttributes,
    true,
    Object.keys(structAttributes)
  );

  {
    let impl = new lib.ImplGenerator(file, `${camelCaseName}Data`);
    const [{ id: baseId }] = dataEntry.states.sort((a, b) => a.id - b.id);
    // pub fn from_offset(offset: usize) -> Option<Self>
    {
      let fn = new lib.FunctionGenerator(
        impl,
        "from_offset",
        "Option<Self>",
        true
      );
      fn.addParam("offset", "usize");
      let match = new lib.MatchGenerator(fn, "offset");
      for (let { properties, id } of dataEntry.states) {
        let setProps = [];
        for (let propName in properties) {
          let propValue = properties[propName];
          setProps.push(
            `${lib.escapeName(propName)}: ${structAttributeTypes
              .get(propName)
              .createRustValue(propValue)}`
          );
        }
        match.addMatchArm(
          "" + (id - baseId),
          `Some(Self {${setProps.join(", ")}})`
        );
      }
      match.addMatchArm("_", "None");
      match.finish();
      fn.finish();
    }
    // pub fn to_offset(self) -> usize
    {
      let fn = new lib.FunctionGenerator(impl, "to_offset", "usize", true);
      fn.addParam("self");
      /**
       * Map all possible combinations as a tree
       * @example bell (attachment => facing => powered => block id)
       * Map {
       *   'floor' => Map {
       *     'north' => Map { 'true' => 11198, 'false' => 11199 },
       *     'south' => Map { 'true' => 11200, 'false' => 11201 },
       *     'west' => Map { 'true' => 11202, 'false' => 11203 },
       *     'east' => Map { 'true' => 11204, 'false' => 11205 }
       *   },
       *   'ceiling' => Map {
       *     'north' => Map { 'true' => 11206, 'false' => 11207 },
       *     'south' => Map { 'true' => 11208, 'false' => 11209 },
       *     'west' => Map { 'true' => 11210, 'false' => 11211 },
       *     'east' => Map { 'true' => 11212, 'false' => 11213 }
       *   },
       *   'single_wall' => Map {
       *     'north' => Map { 'true' => 11214, 'false' => 11215 },
       *     'south' => Map { 'true' => 11216, 'false' => 11217 },
       *     'west' => Map { 'true' => 11218, 'false' => 11219 },
       *     'east' => Map { 'true' => 11220, 'false' => 11221 }
       *   },
       *   'double_wall' => Map {
       *     'north' => Map { 'true' => 11222, 'false' => 11223 },
       *     'south' => Map { 'true' => 11224, 'false' => 11225 },
       *     'west' => Map { 'true' => 11226, 'false' => 11227 },
       *     'east' => Map { 'true' => 11228, 'false' => 11229 }
       *   }
       * }
       * @typedef {Map<string, number | Tree>} Tree
       * @type {Tree}
       */
      let tree = new Map();
      for (let { properties, id } of dataEntry.states) {
        let currentMap = tree;
        let reverseIndex = Object.keys(properties).length - 1;
        for (let propVal of Object.entries(properties)
          .sort(([name1], [name2]) => name1 > name2)
          .map(([_, v]) => v)) {
          if (reverseIndex-- == 0) {
            currentMap.set(propVal, id - baseId);
            break;
          }
          if (currentMap.has(propVal)) {
            currentMap = currentMap.get(propVal);
          } else {
            let newEntry = new Map();
            currentMap.set(propVal, newEntry);
            currentMap = newEntry;
          }
        }
      }
      const propNames = Object.keys(dataEntry.properties).sort((a, b) => a > b);
      /**
       * @param {number} i
       * @param {Tree} map
       * @param {lib.CodeGenerator} parentGen
       */
      const writeMatch = function (i, map, parentGen) {
        let propName = propNames[i];
        let propType = structAttributeTypes.get(propName);
        let match = new lib.MatchGenerator(
          parentGen,
          `self.${propType.getRustValue(propName)}`
        );
        for (let [propVal, next] of map) {
          if (next instanceof Map) {
            // `next` is a Tree
            match.addMatchArm(
              propType.getRustCompareToValue(propVal),
              (gen) => {
                writeMatch(i + 1, next, gen);
              }
            );
          } else {
            // `next` is a number
            match.addMatchArm(
              propType.getRustCompareToValue(propVal),
              "" + next
            );
          }
        }
        if (!propType.exhaustive)
          match.addMatchArm("_", 'panic!("Illegal Block State")');
        match.finish();
      };

      writeMatch(0, tree, fn);

      fn.finish();
    }
    impl.finish();
  }

  // Implement Default
  {
    const defaultState = dataEntry.states.find((s) => s.default);
    let impl = new lib.ImplGenerator(file, `${camelCaseName}Data`, "Default");
    let fn = new lib.FunctionGenerator(impl, "default", "Self");
    fn.writeLine(
      "Self {" +
        Object.entries(defaultState.properties)
          .map(
            ([propName, propValue]) =>
              `${lib.escapeName(propName)}: ${structAttributeTypes
                .get(propName)
                .createRustValue(propValue)}`
          )
          .join(", ") +
        "}"
    );
    fn.finish();
    impl.finish();
  }
}

file.newLine();
file.commentLine("Block state data property structures");
file.newLine();
for (let generator of propertyStructGeneratorFunctions.values()) {
  generator();
}

file.finish();

//
// Useful functions
//

/**
 * Attempts to find a common property type that matches
 * the given possible values, returns `null` if it doesn't find
 * any common type
 * @param {string[]} possibleValues
 * @returns {PropertyType}
 */
function findCommonPropertyType(possibleValues) {
  for (let common of commonPropertyTypes) {
    let commonValues = Object.keys(common.map);
    if (arrayCompare(commonValues, possibleValues)) {
      return common;
    }
  }
  // Create a new number type
  NumCheck: {
    for (let i of possibleValues) if (isNaN(i)) break NumCheck;
    // Apparently, sorting numbers only compares them as strings, so I have to append a compare function
    let sorted = possibleValues.map((s) => parseInt(s)).sort((a, b) => a - b);
    for (let i = 0; i < sorted.length - 1; i++) {
      let a = sorted[i];
      let b = sorted[i + 1];
      if (b - a !== 1) break NumCheck;
    }
    const [min] = sorted;
    const max = sorted[sorted.length - 1];
    const typeName = `NumberFrom${min}To${max}Property`;
    let map = {};
    sorted.forEach((num) => (map["" + num] = `${typeName}::new(${num})`));
    /**
     * @type {PropertyType}
     */
    let pType = {
      map,
      type: typeName,
      bounds: [min, max],
      native: false,
      exhaustive: false,
      generate() {
        file.writeLine("#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]");
        lib.writeStruct(file, typeName, { value: "u8" }, true);
        let impl = new lib.ImplGenerator(file, typeName);
        impl.writeLine(`pub const MIN_VALUE: u8 = ${min};`);
        impl.writeLine(`pub const MAX_VALUE: u8 = ${max};`);
        // pub fn new(value: u8) -> Self
        {
          let fn = new lib.FunctionGenerator(impl, "new", "Self", true);
          fn.addParam("value", "u8");
          fn.writeLine(
            'assert!(value >= Self::MIN_VALUE, "Value {} is smaller than {}", value, Self::MIN_VALUE);',
            'assert!(value <= Self::MAX_VALUE, "Value {} is greater than {}", value, Self::MAX_VALUE);',
            "Self {value}"
          );
          fn.finish();
        }
        // pub fn value(&self) -> u8
        {
          let fn = new lib.FunctionGenerator(impl, "value", "u8", true);
          fn.addParam("&self");
          fn.writeLine("self.value");
          fn.finish();
        }
        // pub fn set(&mut self, new_value: u8)
        {
          let fn = new lib.FunctionGenerator(impl, "set", null, true);
          fn.addParam("&mut self")("new_value", "u8");
          fn.writeLine(
            'assert!(new_value >= Self::MIN_VALUE, "New value {} is smaller than {}", new_value, Self::MIN_VALUE);',
            'assert!(new_value <= Self::MAX_VALUE, "New value {} is greater than {}", new_value, Self::MAX_VALUE);',
            "self.value = new_value;"
          );
          fn.finish();
        }
        impl.finish();
      },
      createRustValue(v) {
        return `${this.type}::new(${v})`;
      },
      getRustValue(prop) {
        return `${prop == "type" ? "r#type" : prop}.value()`;
      },
      getRustCompareToValue(v) {
        return v;
      },
    };
    // Remember this
    commonPropertyTypes.push(pType);
    return pType;
  }
  return null;
}

/**
 * Compares two arrays and returns whether they're equal
 * (only checking the entries, ignoring indices)
 * @template T
 * @param {T[]} arrayA
 * @param {T[]} arrayB
 * @returns {boolean}
 */
function arrayCompare(arrayA, arrayB) {
  if (arrayA.length != arrayB.length) return false;
  let sortA = arrayA.sort();
  let sortB = arrayB.sort();
  for (let i = 0; i < sortA.length; i++) {
    if (sortA[i] !== sortB[i]) return false;
  }
  return true;
}

/**
 * Generates an enum for a specific block property (example: `axis` or `facing`)
 */
function makePropertyStruct() {
  file.writeLine("#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]");
  let enumGen = new lib.EnumGenerator(file, this.type, true);
  for (let propName of Object.values(this.map)) {
    enumGen.addEnumValue(propName);
  }
  enumGen.finish();
  //let implGen = new lib.ImplGenerator(file, this.type);
  //
  //implGen.finish();
}

/**
 * Creates an enum value
 * @param {string} v
 * @returns {string}
 */
function createEnumPropertyValue(v) {
  return `${this.type}::${this.map[v]}`;
}

/**
 * Gets the rust code that can be used to compare
 * to another enum value of the same enum
 * @param {string} v
 * @returns {string}
 */
function getEnumPropertyCompareToValue(v) {
  return `${this.type}::${this.map[v]}`;
}

/**
 * @param {string} val
 * @returns {string}
 */
function getPropertyValue(val) {
  return lib.escapeName(val);
}

/**
 * Creates an array of the string prefixed with every in-game color name
 * @param {string} str
 * @returns {string[]}
 */
function prefixColors(str) {
  return COLORS.map((a) => `${a}_${str}`);
}

/**
 * Creates an array of the string prefixed with every in-game wood name
 * @param {string} str
 * @returns {string[]}
 */
function prefixWood(str) {
  return WOOD_TYPES.map((a) => `${a}_${str}`);
}

/**
 * Filter data for a specific group of blocks by similar ids
 * @param {string} groupName - block group name
 * @param {string} ending - filter for id ending
 * @returns {[string, string][]}
 */
function similarityFilter(groupName, ending) {
  return Object.keys(data)
    .map((id) => lib.NamespacedKey.fromString(id).id)
    .filter((id) => id.endsWith(ending))
    .map((name) => [name, groupName]);
}
