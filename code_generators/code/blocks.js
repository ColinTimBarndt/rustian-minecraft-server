const fs = require('fs');

let writer = fs.createWriteStream('generated_code/blocks.rs', {flags: 'w'})
  .on('finish', () => {
    console.log("Writing operation finished");
  })
  .on('error', (err) => {
    console.warn("Error:");
    console.warn(error.stack);
  });

let data = JSON.parse(fs.readFileSync("generated/reports/blocks.json"));
console.log("Loaded blocks");

writer.write(`\
// This file was automatically generated based on
// data generated by the original java game

#![ignore = "unused"]
use crate::helpers::NamespacedKey;

`);

// Block id bases
writer.write(`\
/// Internal base block ids of all blocks (not including states)
const BLOCK_ID_BASES: [usize; ${Object.keys(data).length}] = [\r\n\t\
`);
{
  let colWidth = 0;
  let largestId = 0;
  for(blockId in data) {
    let [firstState] = data[blockId].states.sort((a, b) => a.id-b.id);
    if(colWidth>80) {
      writer.write("\r\n\t");
      colWidth = 0;
    }
    let s = `${firstState.id},`;
    largestId = Math.max(largestId, firstState.id);
    writer.write(s);
    colWidth += s.length;
  }
  writer.write(`
];

/// Bits needed to represent all block states
pub const USED_PALETTE_BITS: u8 = ${Math.ceil(Math.log2(largestId))};

`);
}

const WOOD_TYPES = Object.entries(data)
    .filter(([name, block]) => parseKey(name).id.endsWith("_planks"))
    .map(([name, block]) => (name=parseKey(name).id).substring(0, name.length-"_planks".length));
const COLORS = Object.entries(data)
    .filter(([name, block]) => parseKey(name).id.endsWith("_stained_glass_pane"))
    .map(([name, block]) => (name=parseKey(name).id).substring(0, name.length-"_stained_glass_pane".length));

// Block enum
const similarStructures = new Map([
  ...[
    "glass_pane",
    ...prefixColors("stained_glass_pane")
  ].map(name=>[name,"glass_pane"]),
  ...prefixColors("bed").map(name=>[name,"bed"]),
  ...prefixColors("banner").map(name=>[name,"banner"]),
  //...prefixColors("wall_banner").map(name=>[name,"wall_banner"]), // Cardinal
  //...prefixColors("glazed_terracotta").map(name=>[name,"glazed_terracotta"]), // Cardinal
  ...similarityFilter("stairs", "_stairs"),
  ...similarityFilter("sign", "_sign"),
  ...similarityFilter("wall_sign", "_wall_sign"),
  ...similarityFilter("wall", "_wall"),
  ...similarityFilter("slab", "_slab"),
  ...similarityFilter("fence", "_fence"),
  ...similarityFilter("fence_gate", "_fence_gate"),
  ...prefixWood("sapling").map(name=>[name,"tree_sapling"]),
  ...prefixWood("door").map(name=>[name,"door"]),
  ...prefixWood("trapdoor").map(name=>[name,"trapdoor"]),
  ...Object.entries(data) // Waterlogged
    .filter(([type, val]) => {
      if(!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      return props.length == 1 && props[0] == "waterlogged";
    }).map(([type, val]) => parseKey(type).id)
    .map(name => [name, "waterlogged"]),
  ...Object.entries(data) // Cardinal
    .filter(([type, val]) => {
      if(!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if(!(props.length == 1 && props[0] == "facing")) return false;
      let {facing} = val.properties;
      return facing.length == 4
        && facing.includes("north")
        && facing.includes("south")
        && facing.includes("west")
        && facing.includes("east");
    }).map(([type, val]) => parseKey(type).id)
    .map(name => [name, "cardinal"]),
  ...Object.entries(data) // Axis
    .filter(([type, val]) => {
      if(!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if(!(props.length == 1 && props[0] == "axis")) return false;
      let {axis} = val.properties;
      return axis.length == 3
        && axis.includes("x")
        && axis.includes("y")
        && axis.includes("z");
    }).map(([type, val]) => parseKey(type).id)
    .map(name => [name, "axis"]),
  ...Object.entries(data) // Block Face
    .filter(([type, val]) => {
      if(!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if(!(props.length == 1 && props[0] == "facing")) return false;
      let {facing} = val.properties;
      return facing.length == 6
        && facing.includes("north")
        && facing.includes("east")
        && facing.includes("south")
        && facing.includes("west")
        && facing.includes("up")
        && facing.includes("down");
    }).map(([type, val]) => parseKey(type).id)
    .map(name => [name, "block_face"]),
  ...Object.entries(data) // Cardinal Lightable
    .filter(([type, val]) => {
      if(!("properties" in val)) return false;
      let props = Object.keys(val.properties);
      if(!(props.length == 2 && props.includes("facing") && props.includes("lit"))) return false;
      let {facing, lit} = val.properties;
      return facing.length == 4 && lit.length == 2
        && facing.includes("north")
        && facing.includes("east")
        && facing.includes("south")
        && facing.includes("west")
        && lit.includes("true")
        && lit.includes("false");
    }).map(([type, val]) => parseKey(type).id)
    .map(name => [name, "cardinal_lightable"]),
  ...[
    ...prefixWood("pressure_plate"),
    "stone_pressure_plate"
  ].map(name=>[name,"pressure_plate"]),
  /*...[
    ...prefixWood("log"),
    ...prefixWood("wood")
  ].flatMap(name=>[[name,"axis"], ["stripped_"+name,"axis"]]),*/
  ...prefixWood("leaves").map(name=>[name,"leaves"]),
  ...["water", "lava"].map(name=>[name,"fluid"]),
  ...["brown", "red"].map(name=>[name+"_mushroom_block","mushroom_block"])
]);
console.log(similarStructures);

let blocksWithData = new Set();
writer.write("#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\r\n");
writer.write("pub enum Block {");
for(let blockId in data) {
  let key = parseKey(blockId);
  const camelCaseName = toCamelCase(key.id);
  let entry = data[blockId];
  let b = "";
  if("properties" in entry) {
    let camelCasePropName = camelCaseName;
    if(similarStructures.has(key.id)) {
      camelCasePropName = toCamelCase(similarStructures.get(key.id));
    }
    b = `(${camelCasePropName}Data)`;
    blocksWithData.add(key.id);
  }
  writer.write(`\r\n\t${camelCaseName}${b},`);
}
writer.write("\r\n}\r\n");

writer.write("\r\nimpl Block {\r\n");
writer.write(`\
  pub fn from_state(state: usize) -> Option<Block> {
    let base = BLOCK_ID_BASES[BLOCK_ID_BASES.binary_search(&state).unwrap_or_else(|x| x-1)];
    match base {\
`);
for(let blockId in data) {
  let [firstState] = data[blockId].states;
  writer.write(`\r\n      ${firstState.id} => `);
  const key = parseKey(blockId);
  const camelCaseName = toCamelCase(key.id);
  if(blocksWithData.has(key.id)) {
    let stateName = similarStructures.has(key.id)?toCamelCase(similarStructures.get(key.id)):camelCaseName;
    stateName += "Data";
    writer.write(`match ${stateName}::from_offset(state-base) {
        Some(s) => Some(Self::${camelCaseName}(s)),
        None => None
      },`
    );
  } else {
    writer.write(`Some(Self::${camelCaseName}),`);
  }
}
writer.write(`\r\n\
      _ => None
    }
  }
  pub fn to_state(self) -> usize {
    match self {`
);
for(let blockId in data) {
  const key = parseKey(blockId);
  const camelCaseName = toCamelCase(key.id);
  writer.write(`\r\n      Self::${camelCaseName}`);
  let [firstState] = data[blockId].states;
  if(blocksWithData.has(key.id)) {
    let stateName = similarStructures.has(key.id)?toCamelCase(similarStructures.get(key.id)):camelCaseName;
    stateName += "Data";
    writer.write(`(s) => ${firstState.id}+s.to_offset(),`);
  } else {
    writer.write(` => ${firstState.id},`);
  }
}
writer.write(`\
    }
  }
  pub fn get_key(&self) -> NamespacedKey {
    match &self {`
);
for(let blockId in data) {
  const key = parseKey(blockId);
  let camelCaseName = toCamelCase(key.id);
  if(blocksWithData.has(key.id)) camelCaseName += "(_)";
  writer.write(`\r\n      Self::${camelCaseName} => ${key.toRust()},`);
}
writer.write(`\
    }
  }
  /*pub fn default_from_key(key: &NamespacedKey, data: HashMap<String, String>) -> Option<Block> {
    if key.0 != "minecraft" {
      return None;
    }
    match key.1 {`
);
/*for(let blockId in data) {
  const key = parseKey(blockId);
  const camelCaseName = toCamelCase(key.id);
  writer.write(`      "${key.id}" => ${key.toRust()}`);
}*/
writer.write(`\
    }
  }*/`
);
writer.write("\r\n}\r\n");

// Block data structures
const similarExistingStructures = new Set();
const propertyStructGeneratorFunctions = new Map();
for(let keyId of blocksWithData) {
  let {properties, states} = data["minecraft:"+keyId];
  if(similarStructures.has(keyId)) {
    keyId = similarStructures.get(keyId);
    if(similarExistingStructures.has(keyId)) continue;
    similarExistingStructures.add(keyId);
  }
  const camelCaseName = toCamelCase(keyId);
  let defaultState = states.find(s => s.default);
  writer.write("\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]");
  writer.write(`\r\npub struct ${camelCaseName}Data {`);
  let structureProperties = {};
  //let neededPropertyStructs = new Map();
  for(let prop in properties) {
    let vals = properties[prop];
    let type = tryUseNativeType(vals);
    if(!type) {
      type = {
        map: {},
        type: `${camelCaseName}${toCamelCase(prop)}Property`,
        native: false,
        make: makePropertyStruct,
        createValue: createPropertyValue,
        getValue: getPropertyValue,
        getComparedValue: getPropertyCompareToValue
      };
      for(let val of vals) {
        type.map[val] = toCamelCase(val);
      }
    }
    if(!type.native && !propertyStructGeneratorFunctions.has(type.type)) {
      //neededPropertyStructs.set(type.type, type);
      propertyStructGeneratorFunctions.set(type.type, ()=>type.make(type));
    }
    structureProperties[prop] = type;
    writer.write(`\r\n\t${prop=="type"?"r#type":prop}: ${type.type},`);
  }
  writer.write("\r\n}");
  writer.write(`\r\nimpl ${camelCaseName}Data {`);
  writer.write("\r\n\tpub fn from_offset(offset: usize) -> Option<Self> {");
  writer.write("\r\n\t\tmatch offset {");
  const baseId = states.sort((a, b) => a.id-b.id)[0].id;
  for(let {properties, id} of states) {
    writer.write(`\r\n\t\t\t${id-baseId} => Some(Self {`);
    writer.write(Object.entries(properties)
      .map(([propName, propVal]) => {
        let sProp = structureProperties[propName];
        return `${propName=="type"?"r#type":propName}: ${sProp.createValue(propVal)}`;
      })
      .join(", ")
    );
    writer.write("}),");
  }
  writer.write("\r\n\t\t\t_ => None");
  writer.write("\r\n\t\t}");
  writer.write("\r\n\t}");
  writer.write("\r\n\tpub fn to_offset(self) -> usize {\r\n\t\t");
  {
    /**
      * Map all possible combinations as a tree
      * @example bell (attachment => facing => powered => block id)
      * Map {
      *   'floor' => Map {
      *     'north' => Map { 'true' => 11198, 'false' => 11199 },
      *     'south' => Map { 'true' => 11200, 'false' => 11201 },
      *     'west' => Map { 'true' => 11202, 'false' => 11203 },
      *     'east' => Map { 'true' => 11204, 'false' => 11205 }
      *   },
      *   'ceiling' => Map {
      *     'north' => Map { 'true' => 11206, 'false' => 11207 },
      *     'south' => Map { 'true' => 11208, 'false' => 11209 },
      *     'west' => Map { 'true' => 11210, 'false' => 11211 },
      *     'east' => Map { 'true' => 11212, 'false' => 11213 }
      *   },
      *   'single_wall' => Map {
      *     'north' => Map { 'true' => 11214, 'false' => 11215 },
      *     'south' => Map { 'true' => 11216, 'false' => 11217 },
      *     'west' => Map { 'true' => 11218, 'false' => 11219 },
      *     'east' => Map { 'true' => 11220, 'false' => 11221 }
      *   },
      *   'double_wall' => Map {
      *     'north' => Map { 'true' => 11222, 'false' => 11223 },
      *     'south' => Map { 'true' => 11224, 'false' => 11225 },
      *     'west' => Map { 'true' => 11226, 'false' => 11227 },
      *     'east' => Map { 'true' => 11228, 'false' => 11229 }
      *   }
      * }
      */
    let tree = new Map();
    for(let {properties, id} of states) {
      let currentMap = tree;
      let reverseIndex = Object.keys(properties).length-1;
      for(let propVal of Object.entries(properties)
          .sort(([name1], [name2]) => name1>name2)
          .map(([_,v]) => v)) {
        if(reverseIndex--==0) {
          currentMap.set(propVal, id-baseId);
          break;
        }
        if(currentMap.has(propVal)) {
          currentMap = currentMap.get(propVal);
        } else {
          let newEntry = new Map();
          currentMap.set(propVal, newEntry);
          currentMap = newEntry;
        }
      }
    }

    const propNames = Object.keys(properties).sort((a, b) => a>b);
    writeMatch(0, tree, 2);

    function writeMatch(i, map, indentBy) {
      let propName = propNames[i];
      let propType = structureProperties[propName];
      const prefix = "\r\n"+"\t".repeat(indentBy);
      // don't prefix the first line
      writer.write(`match self.${propType.getValue(propName)} {`);
      for(let [propVal, next] of map) {
        writer.write(prefix+`\t${propType.getComparedValue(propVal)} => `);
        if(next instanceof Map) {
          writeMatch(i+1, next, indentBy+1);
        } else {
          writer.write(`${next}`);
        }
        writer.write(",");
      }
      writer.write(prefix+`\t_ => panic!("Illegal Block State")`);
      writer.write(prefix+`}`);
    }
  }
  writer.write("\r\n\t}");
  writer.write("\r\n}\r\n");
}

// Create Property Structures
writer.write("\r\n// Property Structures\r\n");

for(let [_, make] of propertyStructGeneratorFunctions) {
  make();
}

// Done
writer.close();

function parseKey(str) {
  let [namespace, id] = str.split(":");
  return {
    namespace,
    id,
    toRust: function() {
      return `NamespacedKey::new("${this.namespace}", "${this.id}")`;
    }
  };
}

function toCamelCase(str, big=true) {
  let res = "";
  for(let char of str) {
    if(big) {
      res += char.toUpperCase();
      big = false;
    } else if(char == '_') {
      big = true;
    } else {
      res += char.toLowerCase();
    }
  }
  return res;
}

function tryUseNativeType(propValues) {
  switch(propValues.length) {
    case 2:
      if(propValues.includes("true") && propValues.includes("false")) {
        return {
          map: {
            "true": "true",
            "false": "false"
          },
          type: "bool",
          native: true,
          make: null,
          createValue: v => v,
          getValue: getPropertyValue,
          getComparedValue: v => v
        };
      }
      if(propValues.includes("head") && propValues.includes("foot")) {
        return {
          map: {
            "head": "Head",
            "foot": "Foot"
          },
          type: "BedPartProperty",
          native: false,
          make: makePropertyStruct,
          createValue: createPropertyValue,
          getValue: getPropertyValue,
          getComparedValue: getPropertyCompareToValue
        };
      }
      break;
    case 3:
      if(propValues.includes("x") && propValues.includes("y")
          && propValues.includes("z")) {
        return {
          map: {
            "x": "X",
            "y": "Y",
            "z": "Z"
          },
          type: "AxisProperty",
          native: false,
          make: makePropertyStruct,
          createValue: createPropertyValue,
          getValue: getPropertyValue,
          getComparedValue: getPropertyCompareToValue
        };
      }
      if(propValues.includes("floor") && propValues.includes("wall")
          && propValues.includes("ceiling")) {
        return {
          map: {
            "floor": "Floor",
            "wall": "Wall",
            "ceiling": "Ceiling"
          },
          type: "FaceProperty",
          native: false,
          make: makePropertyStruct,
          createValue: createPropertyValue,
          getValue: getPropertyValue,
          getComparedValue: getPropertyCompareToValue
        };
      }
      if(propValues.includes("single") && propValues.includes("left")
          && propValues.includes("right")) {
        return {
          map: {
            "single": "Single",
            "left": "Left",
            "right": "Right"
          },
          type: "ChestTypeProperty",
          native: false,
          make: makePropertyStruct,
          createValue: createPropertyValue,
          getValue: getPropertyValue,
          getComparedValue: getPropertyCompareToValue
        };
      }
      if(propValues.includes("up") && propValues.includes("side")
          && propValues.includes("none")) {
        return {
          map: {
            "up": "Up",
            "side": "Side",
            "none": "None"
          },
          type: "RedstoneWireConnectionProperty",
          native: false,
          make: makePropertyStruct,
          createValue: createPropertyValue,
          getValue: getPropertyValue,
          getComparedValue: getPropertyCompareToValue
        };
      }
      break;
    case 4:
      if(propValues.includes("north") && propValues.includes("south")
          && propValues.includes("west") && propValues.includes("east")) {
        return {
          map: {
            "north": "North",
            "south": "South",
            "west": "West",
            "east": "East"
          },
          type: "CardinalFacingProperty",
          native: false,
          make: makePropertyStruct,
          createValue: createPropertyValue,
          getValue: getPropertyValue,
          getComparedValue: getPropertyCompareToValue
        };
      }
      break;
    case 6:
      if(propValues.includes("north") && propValues.includes("south")
          && propValues.includes("west") && propValues.includes("east")
          && propValues.includes("up") && propValues.includes("down")) {
        return {
          map: {
            "north": "North",
            "south": "South",
            "west": "West",
            "east": "East",
            "up": "Up",
            "down": "Down"
          },
          type: "BlockFacingProperty",
          native: false,
          make: makePropertyStruct,
          createValue: createPropertyValue,
          getValue: getPropertyValue,
          getComparedValue: getPropertyCompareToValue
        };
      }
      break;
  }
  NumCheck: {
    for(let i of propValues) if(isNaN(i)) break NumCheck;
    let sorted = propValues.map(s => parseInt(s)).sort();
    const [min] = sorted;
    const max = sorted[sorted.length-1];
    const type = `NumberFrom${min}To${max}Property`;
    let map = {};
    for(let i of propValues) map[i] = `${type}::new(${i})`;
    return {
      map,
      type,
      bounds: [min, max],
      native: false,
      make: () => {
        writer.write("\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]");
        writer.write(`\r\npub struct ${type} {`);
        writer.write(`\r\n\tvalue: u8`);
        writer.write(`\r\n}`);
        writer.write(`\r\nimpl ${type} {`);
        writer.write(`\r\n\tpub const MIN_VALUE: u8 = ${min};`);
        writer.write(`\r\n\tpub const MAX_VALUE: u8 = ${max};`);
        writer.write(`\r\n\tpub fn new(value: u8) -> Self {\r\n\t\t${
          [
            `assert!(value >= Self::MIN_VALUE, "Value {} is smaller than {}", value, Self::MIN_VALUE);`,
            `assert!(value <= Self::MAX_VALUE, "Value {} is greater than {}", value, Self::MAX_VALUE);`,
            `Self {value}`
          ].join("\r\n\t\t")
        }\r\n\t}`);
        writer.write(`\r\n\tpub fn value(&self) -> u8 {\r\n\t\tself.value\r\n\t}`);
        writer.write(`\r\n\tpub fn set(&mut self, new_value: u8) {\r\n\t\t${
          [
            `assert!(new_value >= Self::MIN_VALUE, "New value {} is smaller than {}", new_value, Self::MIN_VALUE);`,
            `assert!(new_value <= Self::MAX_VALUE, "New value {} is greater than {}", new_value, Self::MAX_VALUE);`,
            `self.value = new_value;`
          ].join("\r\n\t\t")
        }\r\n\t}`);
        writer.write(`\r\n}\r\n`);
      },
      createValue: v => `${type}::new(${v})`,
      getValue: prop => `${prop=="type"?"r#type":prop}.value()`,
      getComparedValue: v => v
    }
  }
  return null;
}

function makePropertyStruct() {
  writer.write("\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]");
  writer.write(`\r\npub enum ${this.type} {`);
  for(let enumName of Object.values(this.map))
    writer.write(`\r\n\t${enumName},`);
  writer.write(`\r\n}`);
  writer.write(`\r\nimpl ${this.type} {`);
  //
  writer.write(`\r\n}\r\n`);
}

function createPropertyValue(v) {
  return `${this.type}::${this.map[v]}`;
}

function getPropertyValue(prop) {
  return `${prop=="type"?"r#type":prop}`;
}

function getPropertyCompareToValue(v) {
  return `${this.type}::${this.map[v]}`;
}

function prefixColors(str) {
  return COLORS.map(a => `${a}_${str}`);
}

function prefixWood(str) {
  return WOOD_TYPES.map(a => `${a}_${str}`);
}

function similarityFilter(groupName, ending) {
  return Object.keys(data).map(id=>parseKey(id).id).filter(id=>id.endsWith(ending)).map(name=>[name,groupName]);
}
